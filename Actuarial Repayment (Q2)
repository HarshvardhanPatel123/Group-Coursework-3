#Question 2
#Part i

ann.loan <- function(type, n, x, i, p ) {
  if (n < 1 || n > 25 ||  n != as.integer(n)) { # Length of the annuity or the loan repayment
    stop("The length of the annuity must have a maximum of 25 years and be an integer!")
  }
  if (x <= 0) { # The total annual payment, will be separate into payment intervals at the choice of the user
    stop("The total annual payment/toal loan amount to be repaid cannot be negative!")
  }
  if (i <= 0 || i >= 1) { # Interest rate on the loan
    stop("Interest rate must be inputted as a decimal number between 0 and 1!")
  }
  if (!(p %in% c(1, 2, 3, 4, 6, 12))) { # The number of annual payments contributing to the annuity or the loan repayment
    stop("Number of payments payable annually must be monthly, every 2 months, quarterly, every 4 months, half-yearly or once per year. \n  Hence, please input 12, 6, 4, 3, 2 or 1 respectively")
  }
  rate <- i / p # The rate per period
  total_periods <- n * p # The total period
  
  if (type == "ann") { # Annuity calculation
    present_value <- x * ((1 - (1 + rate)^(-total_periods)) / rate) 
    return(present_value)
  } else if (type == "loan") { # Loan calculation
    payment_per_period <- x * (rate / (1 - (1 + rate)^(-total_periods)))
    total_annual_payment <- payment_per_period * p
    return(total_annual_payment)
  } else {
    stop("Invalid type! Enter 'ann' or 'loan'.")
  }
}

test_ann <- ann.loan("ann", 25, 1500, 0.2, 6) # Annuity with total annual payment of 1200
print (test_ann)
test_loan <- ann.loan("loan", 7, 2700, 0.056, 1) # Loan of 10000 to be repaid
print(test_loan)


#Part ii

analyse.policies <- function(file_path){ # The file path is decided by the user, thus will be involved in calling the function 
  policy_file <- "Path.csv" # File names decided for the user to alter later
  annuities_output <- "Annuities_Return.csv"
  loans_output <- "Loans_Return.csv"
  summary_output <- "Summary_Stats.csv"
  
  policyholder_file <- read.csv(file_path) # Reading the file using the csv function
  
  # Data frames are used to make it simple to access and utilize data within R
  annuities_results <- data.frame()
  loans_results <- data.frame()
  errors <- data.frame() # This is an extra data frame which will later be appended to the bottom of the respective table
  
  for (row in 1:nrow(policyholder_file)) {
    tryCatch({ # Try catch is a loop which decides where the result of each person (row) is stored in which data frame, but also for spotting errors and placing them in a seperate data frame
      type <- ifelse(policyholder_file$type[row] == 1, "ann", "loan") # Adhering to the code word given, 1 is for annuity and 2 is for loan
      n <- policyholder_file$n[row]
      x <- policyholder_file$x[row]
      i <- policyholder_file$i[row]
      p <- policyholder_file$p[row]
      # After making the row values in the CSV file temporary variables, we can apply the function to it
      current_result <- ann.loan(type, n, x, i, p) # This uses the function in part i to gain a result per row
      
      row_result <- cbind(policyholder_file[row, ], Result <- current_result) # Appending the result of the ann.loan function to the correct data frame
      
      if (type =="ann") { # If statement important for choosing correct data frame
        annuities_results <- rbind(annuities_results, row_result)
      } else {
        loans_results <- rbind(loans_results, row_result)
      }
    }, 
      errors <- rbind(errors, policyholder_file[row, ]) # The errors are appended to the errors data frame
    )
  }
  
  annuities_results <- rbind(annuities_results[order(annuities_results$surname), ], errors[errors$type == 1, ]) # The surname is the sorting factor here, and the data frames are rearranged
  loans_results <- rbind(loans_results[order(loans_results$surname), ], errors[errors$type == 2, ]) # Further rearrangement of the data frame includes the error data frame being appended to the bottom
  
  write.csv(annuities_results, "Annuities_Return.csv", row.names = FALSE) # R function write.csv is used to append the data frames to a CSV file
  write.csv(loans_results, "Loans_Return.csv", row.names = FALSE) # row.names = FALSE is designed to remove the row names, and only print the columns with the original output and results
